<div class="problem-statement"><div class="header"><h1 class="title">N*. CString</h1><table><tbody><tr class="time-limit"><td class="property-title">Ограничение времени</td><td>0.1&nbsp;секунда</td></tr><tr class="memory-limit"><td class="property-title">Ограничение памяти</td><td>8&nbsp;Мб</td></tr><tr class="input-file"><td class="property-title">Ввод</td><td colspan="1">стандартный ввод или input.txt</td></tr><tr class="output-file"><td class="property-title">Вывод</td><td colspan="1">стандартный вывод или output.txt</td></tr></tbody></table></div><h2></h2><div class="legend"><p><em>C-style строкой называется последовательность байт (<code>char</code>), ограниченная нулевым символом (<code>'\0'</code>). Работа с C-style строками во многом похожа на работу с массивами, при этом специфичные для строк операции (вычисление длины, конкатенация, сравнение и т.п.) вынесены в отдельную библиотеку функций <code>&lt;cstring&gt;</code>. В этом задании вам предстоит познакомиться с ней подробнее, реализовав собственный аналог.</em></p> 
<h3 id="условие-задачи">Условие задачи</h3> 
<p>Реализуйте модуль <code>cstring</code>, состоящий из следующих функций:</p> 
<ol type="1"> 
 <li><p><code>size_t Strlen(const char* str);</code>. Вычисляет длину строки <code>str</code> (без учета нулевого символа).</p></li> 
 <li><p><code>int Strcmp(const char* first, const char* second);</code>. Лексикографически сравнивает две строки. Если <code>first &lt; second</code>, то возвращает произвольное отрицательное число, если <code>first &gt; second</code>, то - положительное. В случае равенства возвращает <code>0</code>.</p></li> 
 <li><p><code>int Strncmp(const char* first, const char* second, size_t count);</code>. То же, что и предыдущая функция, но сравнивает первые <code>count</code> символов строк (либо пока не встретит нулевой символ).</p></li> 
 <li><p><code>const char* Strchr(const char* str, char symbol);</code>. Возвращает указатель на первое появление символа <code>symbol</code> в строке <code>str</code> (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.</p></li> 
 <li><p><code>const char* Strrchr(const char* str, char symbol);</code>. Возвращает указатель на последнее появление символа <code>symbol</code> в строке <code>str</code> (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.</p></li> 
 <li><p><code>size_t Strspn(const char* dest, const char* src);</code>. Возвращает количество первых символов <code>dest</code>, которые встречаются в строке <code>src</code> (без учета нулевого символа).</p></li> 
 <li><p><code>size_t Strcspn(const char* dest, const char* src);</code>. Возвращает количество первых символов <code>dest</code>, которые <strong>не</strong> встречаются в строке <code>src</code> (без учета нулевого символа).</p></li> 
 <li><p><code>const char* Strpbrk(const char* dest, const char* breakset);</code>. Возвращает указатель на первый элемент <code>dest</code>, который лежит в <code>breakset</code>, либо нулевой указатель, если такого элемента нет.</p></li> 
 <li><p><code>const char* Strstr(const char* str, const char* pattern);</code>. Осуществляет поиск подстроки <code>pattern</code> в строке <code>str</code>. Возвращает указатель на начало первого вхождения, либо нулевой указатель, если вхождения найдено не было.</p></li> 
 <li><p><code>char* Strcpy(char* dest, const char* src);</code>. Принимает строку <code>src</code> и копирует ее содержимое (вместе с нуль-терминатором) в <code>dest</code>. Гарантируется, что <code>dest</code> указывает на область памяти, достаточную для хранения <code>src</code>. Возвращает <code>dest</code>. <strong>Замечание: формально, std::strcpy дополнительно требует, чтобы последовательности dest и src не перекрывались (то есть длина строки src должна быть больше расстояния между указателями), так как порядок копирования символов не определен. В этом задании допускается более слабое предположение: dest не указывает внутрь строки src.</strong></p></li> 
 <li><p><code>char* Strncpy(char* dest, const char* src, size_t count);</code>. То же, что и предыдущая функция, но копирует ровно <code>count</code> символов из <code>src</code>. Если <code>count</code> больше размера <code>src</code>, то оставшиеся символы заполняются нуль-символами. Возвращает <code>dest</code>.</p></li> 
 <li><p><code>char* Strcat(char* dest, const char* src);</code>. Приписывает строку <code>src</code> в конец строки <code>dest</code> (конкатенация строк). Гарантируется, что <code>dest</code> указывает на область памяти, достаточную для хранения итоговой строки. Возвращает <code>dest</code>.</p></li> 
 <li><p><code>char* Strncat(char* dest, const char* src, size_t count);</code>. То же, что и предыдущая функция, но добавляет только первые <code>count</code> символов из <code>src</code> + нулевой символ. Если <code>count</code> больше чем длина <code>src</code>, то работает так же как и <code>Strcat(dest, src)</code>. Возвращает <code>dest</code>.</p></li> 
</ol> 
<p>При необходимости подробнее про работу функций можете прочитать на странице <a href="https://cplusplus.com/reference/cstring/">https://cplusplus.com/reference/cstring/</a> . <strong>Использовать функции memcpy, memcmp и подобные запрещено.</strong></p> 
<p>В качестве решения от вас ожидается модуль, состоящий из 2х файлов: <code>cstring.h</code> и <code>cstring.cpp</code>. Файлы присылайте в виде <strong>ZIP</strong>-архива.</p> 
<p>Присланный модуль будет собран вместе с файлом с тестами на сервере, <code>main</code> присылать <strong>не нужно</strong>. Интерфейс функций должен в точности совпадать с тем, что описан в условии (тесты ожидают именно его), в противном случае вы получите ошибку компиляции.</p> 
<p>При ошибке в реализации вы получите вердикт <code>CE</code>. В нем будет указана функция, которая требует исправлений.</p></div></div>
